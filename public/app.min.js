'use strict';

function err() {
    throw new Error('Something went wrong!');
}
/**
 * inputs and outputs are [0, 1], except h.
 */
function hsvToRgb(h, s, v) {
    if (s === 0) {
        return [v, v, v];
    }
    if (h >= 360) {
        h = 0;
    }
    h /= 60;
    const i = Math.floor(h);
    const ff = h - i;
    const p = v * (1 - s);
    const q = v * (1 - (s * ff));
    const t = v * (1 - (s * (1 - ff)));
    switch (i) {
        case 0:
            return [v, t, p];
        case 1:
            return [q, v, p];
        case 2:
            return [p, v, t];
        case 3:
            return [p, q, v];
        case 4:
            return [t, p, v];
        case 5:
        default:
            return [v, p, q];
    }
}
//# sourceMappingURL=utils.js.map

const canvas = document.getElementById('canvas');
const context = canvas.getContext('2d') || err();
canvas.width = 1920;
canvas.height = 1080;
const targetAspect = canvas.width / canvas.height;
context.imageSmoothingEnabled = false;
function resize() {
    const aspect = window.innerWidth / window.innerHeight;
    if (aspect > targetAspect) {
        canvas.style.height = window.innerHeight + 'px';
        canvas.style.width = (window.innerWidth * targetAspect / aspect) + 'px';
    }
    else {
        canvas.style.width = window.innerWidth + 'px';
        canvas.style.height = (window.innerHeight * aspect / targetAspect) + 'px';
    }
}
resize();
window.addEventListener('resize', resize);
document.body.appendChild(canvas);

const v2 = {
    create(x = 0, y = 0) {
        return [x, y];
    },
    set(result, x = 0, y = 0) {
        result[0] = x;
        result[1] = y;
    },
    clone(result, a) {
        result[0] = a[0];
        result[1] = a[1];
    },
    isZero(a) {
        return a[0] === 0 && a[1] === 0;
    },
    normalise(result, a) {
        if (!v2.isZero(a)) {
            const length = v2.length(a);
            result[0] = a[0] / length;
            result[1] = a[1] / length;
        }
    },
    lengthSquared(a) {
        return a[0] ** 2 + a[1] ** 2;
    },
    length(a) {
        return Math.sqrt(v2.lengthSquared(a));
    },
    distanceSquared(a, b) {
        return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2;
    },
    distance(a, b) {
        return Math.sqrt(this.distanceSquared(a, b));
    },
    angle(a) {
        return Math.atan2(a[1], a[0]);
    },
    add(result, a, b) {
        result[0] = a[0] + b[0];
        result[1] = a[1] + b[1];
    },
    sub(result, a, b) {
        result[0] = a[0] - b[0];
        result[1] = a[1] - b[1];
    },
    mul(result, a, scalar) {
        result[0] = a[0] * scalar;
        result[1] = a[1] * scalar;
    },
    rotate(result, a, angle) {
        const s = Math.sin(angle);
        const c = Math.cos(angle);
        const x = a[0];
        const y = a[1];
        result[0] = c * x - s * y;
        result[1] = s * x + c * y;
    },
    invert(result, a) {
        result[0] = -a[0];
        result[1] = -a[1];
    },
    dot(a, b) {
        return a[0] * b[0] + a[1] * b[1];
    },
};
//# sourceMappingURL=maths.js.map

// GJK/Mikowski collision
const ao = v2.create();
const ab = v2.create();
const ac = v2.create();
function update(simplex, direction) {
    const last = simplex[simplex.length - 1];
    const n = simplex.length;
    if (n === 1) {
        direction[0] = -last[0];
        direction[1] = -last[1];
        return false;
    }
    v2.invert(ao, last);
    v2.sub(ab, simplex[0], last);
    if (n === 2) {
        direction[0] = -ab[1];
        direction[1] = ab[0];
        if (v2.dot(direction, ao) < 0) {
            direction[0] = -direction[0];
            direction[1] = -direction[1];
        }
        return false;
    }
    if (n === 3) {
        direction[0] = -ab[1];
        direction[1] = ab[0];
        if (v2.dot(direction, simplex[1]) > 0) {
            direction[0] = -direction[0];
            direction[1] = -direction[1];
        }
        if (v2.dot(direction, ao) > 0) {
            simplex[1] = simplex[2];
            const old = simplex.pop();
            return false;
        }
        v2.sub(ac, simplex[1], last);
        direction[0] = -ac[1];
        direction[1] = ac[0];
        if (v2.dot(direction, simplex[0]) > 0) {
            direction[0] = -direction[0];
            direction[1] = -direction[1];
        }
        if (v2.dot(direction, ao) > 0) {
            simplex.shift();
            return false;
        }
        return true;
    }
    return false;
}
const inverseDirection = v2.create();
function combineSupport(support1, support2) {
    // TODO: cache these functions
    return (direction) => {
        v2.invert(inverseDirection, direction);
        const s1 = support1(direction);
        const s2 = support2(inverseDirection);
        v2.sub(s1, s1, s2);
        return s1;
    };
}
function intersect(support1, support2) {
    return intersection(combineSupport(support1, support2));
}
function intersection(support) {
    const simplex = [];
    const direction = v2.create(1, 0);
    while (true) {
        const a = support(direction);
        if (v2.dot(a, direction) < 0) {
            return false;
        }
        simplex.push(a);
        if (update(simplex, direction)) {
            return true;
        }
    }
}
//# sourceMappingURL=collision.js.map

var Key;
(function (Key) {
    Key[Key["Left"] = 37] = "Left";
    Key[Key["Up"] = 38] = "Up";
    Key[Key["Right"] = 39] = "Right";
    Key[Key["Down"] = 40] = "Down";
    Key[Key["A"] = 65] = "A";
    Key[Key["D"] = 68] = "D";
    Key[Key["S"] = 83] = "S";
    Key[Key["W"] = 87] = "W";
})(Key || (Key = {}));
const keystate = {};
const controls = {
    isPressed(key) {
        return keystate[key];
    },
};
function keydown(e) {
    keystate[e.keyCode] = true;
}
function keyup(e) {
    keystate[e.keyCode] = false;
}
document.addEventListener('keydown', keydown);
document.addEventListener('keyup', keyup);

class Graphic {
    constructor(file, x, y) {
        this.file = file;
        this.x = x;
        this.y = y;
        this.width = 32;
        this.height = 32;
    }
    draw(ctx, pos, dim, facing) {
        // TODO: Debug draw for now
        ctx.save();
        ctx.translate(pos[0], pos[1]);
        ctx.fillStyle = 'orange';
        ctx.strokeStyle = 'white';
        ctx.beginPath();
        ctx.arc(0, 0, dim[0] / 2, 0, Math.PI * 2, false);
        ctx.fill();
        ctx.stroke();
        if (facing === Facing.Left) {
            ctx.fillRect(-(5 * dim[0] / 8), -dim[0] / 4, dim[0] / 8, dim[0] / 2);
        }
        else {
            ctx.fillRect(dim[0] / 2, -dim[0] / 4, dim[0] / 8, dim[0] / 2);
        }
        ctx.restore();
    }
}

const playerGraphic = new Graphic('sprites.png', 0, 2);
const fallbackGraphic = new Graphic('sprites.png', 1, 2);
const g = [0, -980];
var EntityType;
(function (EntityType) {
    EntityType[EntityType["Player"] = 0] = "Player";
    EntityType[EntityType["Heart"] = 1] = "Heart";
    EntityType[EntityType["Mcguffin"] = 2] = "Mcguffin";
    EntityType[EntityType["Goblin"] = 3] = "Goblin";
    EntityType[EntityType["Projectile"] = 4] = "Projectile";
})(EntityType || (EntityType = {}));
var Faction;
(function (Faction) {
    Faction[Faction["Foe"] = 0] = "Foe";
    Faction[Faction["Friend"] = 1] = "Friend";
})(Faction || (Faction = {}));
var Facing;
(function (Facing) {
    Facing[Facing["Left"] = 0] = "Left";
    Facing[Facing["Right"] = 1] = "Right";
})(Facing || (Facing = {}));
var CollisionResponse;
(function (CollisionResponse) {
    CollisionResponse[CollisionResponse["Bounce"] = 0] = "Bounce";
    CollisionResponse[CollisionResponse["Stop"] = 1] = "Stop";
    CollisionResponse[CollisionResponse["Deflect"] = 2] = "Deflect";
    CollisionResponse[CollisionResponse["TurnAround"] = 3] = "TurnAround";
})(CollisionResponse || (CollisionResponse = {}));
class Entity {
    constructor(type, pos, options = {}) {
        this.pos = v2.create();
        this.dP = v2.create();
        this.v = v2.create();
        this.dV = v2.create();
        this.facing = Facing.Right;
        // flags
        this.collidable = true; // Does this entity interact with things in the same space?
        this.killable = false;
        this.controlled = false;
        // solid = false; // Solid entities cannot be in the same space as each other
        this.limitedLife = false;
        this.harmful = false;
        this.flying = false;
        this.onGround = false;
        this.pacer = false;
        this.destroyOnUse = false;
        this.collectable = false;
        this.collisionResponse = CollisionResponse.Deflect;
        this.health = 0;
        this.maxHealth = 100;
        this.speed = 1000;
        this.lifespan = 0;
        this.damage = 0;
        this.faction = Faction.Foe;
        // TODO: Weapons should be their own thing, not part of entity
        this.weaponTimer = 0;
        this.weaponRange = 500;
        this.radius = 8;
        this.target = null;
        this.graphic = fallbackGraphic;
        v2.clone(this.pos, pos);
        switch (type) {
            case EntityType.Player: {
                this.controlled = true;
                this.killable = true;
                this.maxHealth = 100;
                this.graphic = playerGraphic;
                this.speed = 2000;
                // this.solid = true;
                this.faction = Faction.Friend;
                break;
            }
            case EntityType.Goblin: {
                this.killable = true;
                this.maxHealth = 20;
                // this.graphic =
                this.speed = 1000;
                // this.solid = true;
                this.pacer = true;
                this.harmful = true;
                this.damage = 100;
                this.collisionResponse = CollisionResponse.TurnAround;
                break;
            }
            case EntityType.Projectile: {
                // this.graphic =
                this.facing = options.facing || Facing.Left;
                this.faction = options.faction || Faction.Foe;
                v2.set(this.v, 1000, 0);
                if (this.facing === Facing.Left) {
                    v2.invert(this.v, this.v);
                }
                this.radius = 4;
                this.limitedLife = true;
                this.lifespan = 2;
                this.harmful = true;
                this.damage = 10;
                this.flying = true;
                this.destroyOnUse = true;
                break;
            }
            case EntityType.Heart: {
                // this.graphic =
                this.faction = Faction.Friend;
                this.radius = 6;
                this.collectable = true;
                this.health = 10;
                break;
            }
        }
        if (this.killable) {
            this.health = this.maxHealth;
        }
    }
    update(dT) {
        v2.set(this.dV, 0, 0);
        if (this.weaponTimer > 0) {
            this.weaponTimer = Math.max(0, this.weaponTimer - dT);
        }
        if (this.limitedLife) {
            this.lifespan -= dT;
        }
        if (this.lifespan < 0) {
            this.die();
        }
        if (this.health <= 0 && this.killable) {
            this.die();
        }
        if (this.controlled) {
            this.playerControl(dT);
        }
        else {
            if (this.pacer) {
                this.dV[0] = this.facing === Facing.Left ? -1 : 1;
            }
            if (this.target) {
                const tVec = v2.create();
                v2.sub(tVec, this.target.pos, this.pos);
                const direction = v2.angle(tVec);
                this.facing = this.target.pos[0] < this.pos[0] ? Facing.Left : Facing.Right;
                if (this.weaponRange >= v2.length(tVec)) {
                    this.shoot();
                }
                v2.normalise(tVec, tVec);
                // v2.clone(this.dV, tVec);
            }
        }
        v2.mul(this.dV, this.dV, this.speed);
        if (!this.onGround && !this.flying) {
            v2.mul(this.dV, this.dV, 0.2);
        }
        // Friction
        const fricAcc = v2.create();
        v2.mul(fricAcc, this.v, this.onGround ? -8 : -1);
        v2.add(this.dV, this.dV, fricAcc);
        if (!this.flying) {
            v2.add(this.dV, this.dV, g);
        }
        v2.mul(this.dV, this.dV, dT); // a => at
        // equations of motion
        // v = at + u
        v2.add(this.v, this.dV, this.v);
        // dP = ut + (1/2)at^2
        const ut = v2.create();
        v2.mul(ut, this.v, dT);
        v2.mul(this.dP, this.dV, 0.5 * dT); // dP = (1/2)at^2
        v2.add(this.dP, ut, this.dP);
        this.onGround = false;
        if (this.collidable) {
            let attempts = 4;
            while (attempts--) {
                const collision = worldMap.findCollision(this);
                if (collision.time < 1 && !v2.isZero(collision.normal)) {
                    if (collision.normal[1] > 0.5) {
                        this.onGround = true;
                    }
                    if (attempts === 0) {
                        v2.set(this.dP, 0, 0);
                    }
                    else {
                        this.updateMove(collision.normal, collision.time);
                    }
                    this.hit(null, dT);
                }
            }
        }
        for (const other of entities) {
            if (other !== this && other.collidable && this.willCollide(other)) {
                this.hit(other, dT);
                other.hit(this, dT);
                // if (this.solid && other.solid) {
                //   // TODO: bouncing/deflection here
                //   v2.set(this.dP, 0, 0);
                // }
            }
        }
        if (this.v[0] !== 0) {
            this.facing = this.v[0] < 0 ? Facing.Left : Facing.Right;
        }
        v2.add(this.pos, this.pos, this.dP);
    }
    shoot() {
        if (this.weaponTimer === 0) {
            entities.add(new Entity(EntityType.Projectile, this.pos, { facing: this.facing, faction: this.faction }));
            this.weaponTimer += 0.1;
        }
    }
    playerControl(dT) {
        v2.set(this.dV, 0, 0);
        if (controls.isPressed(Key.W) && this.onGround) {
            this.v[1] += 600;
        }
        // if (controls.isPressed(Key.S)) {
        //   this.dV[1] = -1;
        // }
        if (controls.isPressed(Key.A)) {
            this.dV[0] = -1;
        }
        if (controls.isPressed(Key.D)) {
            this.dV[0] = 1;
        }
        if (controls.isPressed(Key.Down)) {
            this.shoot();
        }
        v2.normalise(this.dV, this.dV);
    }
    collisionSupport(direction) {
        const result = v2.create();
        v2.normalise(direction, direction);
        v2.mul(result, direction, this.radius);
        v2.add(result, this.pos, result);
        if (!v2.isZero(this.dP)) {
            const angle = v2.dot(this.dP, direction);
            if (angle > 0) {
                v2.add(result, result, this.dP);
            }
        }
        return result;
    }
    willCollide(other) {
        // Assume that all entities are circles for collision
        const support = this.collisionSupport;
        return intersect(support.bind(this), support.bind(other));
    }
    updateMove(normal, proportion) {
        let bounceAmount = 1 - proportion;
        if (this.collisionResponse === CollisionResponse.Bounce) {
            bounceAmount += 0.9;
        }
        switch (this.collisionResponse) {
            case CollisionResponse.TurnAround: {
                if (this.dP[0] !== 0) {
                    this.facing = this.facing === Facing.Left ? Facing.Right : Facing.Left;
                }
            }
            case CollisionResponse.Bounce:
            case CollisionResponse.Deflect: {
                const vDiff = v2.create();
                const dpDiff = v2.create();
                v2.mul(dpDiff, normal, bounceAmount * v2.dot(this.dP, normal));
                v2.sub(this.dP, this.dP, dpDiff);
                v2.mul(vDiff, normal, bounceAmount * v2.dot(this.v, normal));
                v2.sub(this.v, this.v, vDiff);
                break;
            }
            case CollisionResponse.Stop: {
                v2.set(this.dP, 0, 0);
                v2.set(this.v, 0, 0);
                break;
            }
        }
    }
    /**
     * If other is null then we collided with a wall
     */
    hit(other, dT) {
        if (!other) {
            if (this.harmful && this.destroyOnUse) {
                this.die();
            }
            return;
        }
        if (this.killable && other.harmful && this.faction !== other.faction) {
            if (other.destroyOnUse) {
                this.health -= other.damage;
                other.die();
            }
            else {
                this.health -= other.damage * dT;
            }
        }
        if (this.collectable && this.faction === other.faction) {
            if (this.health > 0 && other.health < other.maxHealth) {
                other.health = Math.min(other.maxHealth, other.health + this.health);
                this.die();
            }
        }
    }
    die() {
        entities.delete(this);
        if (this === player) {
            newLevel();
        }
    }
}

const TILE_SIZE = 32;
const tileColors = [];
const s = 1;
const highV = 0.8;
const lowV = 0.5;
for (let i = 0; i < 16; i++) {
    const h = (360 / 16) * i;
    const [r, g, b] = hsvToRgb(h, s, highV);
    const [dr, dg, db] = hsvToRgb(h, s, lowV);
    tileColors[i] = {
        dark: `rgb(${Math.floor(dr * 256)}, ${Math.floor(dg * 256)}, ${Math.floor(db * 256)}`,
        light: `rgb(${Math.floor(r * 256)}, ${Math.floor(g * 256)}, ${Math.floor(b * 256)}`,
    };
}
class WorldMap {
    constructor() {
        this.tiles = [
            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
            [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        ];
        for (const row of this.tiles) {
            for (let x = 0; x < row.length; x++) {
                if (row[x] !== 0) {
                    row[x] = Math.floor(Math.random() * 15) + 1;
                }
            }
        }
    }
    willCollide(entity, tileX, tileY) {
        const entitySupport = entity.collisionSupport.bind(entity);
        const tileSupport = (direction) => {
            const result = v2.create(tileX * TILE_SIZE, tileY * TILE_SIZE);
            if (direction[0] > 0) {
                result[0] += TILE_SIZE;
            }
            if (direction[1] > 0) {
                result[1] += TILE_SIZE;
            }
            return result;
        };
        return intersect(entitySupport, tileSupport);
    }
    findCollision(entity) {
        const minX = Math.min(entity.dP[0], 0) + entity.pos[0] - entity.radius;
        const minY = Math.min(entity.dP[1], 0) + entity.pos[1] - entity.radius;
        const maxX = Math.max(entity.dP[0], 0) + entity.pos[0] + entity.radius;
        const maxY = Math.max(entity.dP[1], 0) + entity.pos[1] + entity.radius;
        const minTileX = Math.max(0, Math.floor(minX / TILE_SIZE));
        const minTileY = Math.max(0, Math.floor(minY / TILE_SIZE));
        const maxTileX = Math.floor(maxX / TILE_SIZE);
        const maxTileY = Math.floor(maxY / TILE_SIZE);
        const currentTileX = Math.floor(entity.pos[0] / TILE_SIZE);
        const currentTileY = Math.floor(entity.pos[1] / TILE_SIZE);
        const normal = [0, 0];
        let bestTime = 1;
        for (let y = minTileY; y <= maxTileY && y < this.tiles.length; y++) {
            const row = this.tiles[y];
            for (let x = minTileX; x <= maxTileX && x < row.length; x++) {
                if (row[x] !== 0) {
                    if (this.willCollide(entity, x, y)) {
                        const tileNormal = [0, 0];
                        let tileTime = 1;
                        const tileLeft = x * TILE_SIZE;
                        const tileRight = tileLeft + TILE_SIZE;
                        const tileBottom = y * TILE_SIZE;
                        const tileTop = tileBottom + TILE_SIZE;
                        if (tileTop < entity.pos[1]) {
                            tileNormal[1] = 1;
                            if (entity.dP[1] < 0) {
                                const distance = ((y + 1) * TILE_SIZE) - (entity.pos[1] - entity.radius);
                                tileTime = Math.min(distance / entity.dP[1], tileTime);
                            }
                        }
                        else if (tileBottom > entity.pos[1]) {
                            tileNormal[1] = -1;
                            if (entity.dP[1] > 0) {
                                const distance = (y * TILE_SIZE) - (entity.pos[1] + entity.radius);
                                tileTime = Math.min(distance / entity.dP[1], tileTime);
                            }
                        }
                        else if (tileRight < entity.pos[0]) {
                            tileNormal[0] = 1;
                            if (entity.dP[0] < 0) {
                                const distance = ((x + 1) * TILE_SIZE) - (entity.pos[0] - entity.radius);
                                tileTime = Math.min(distance / entity.dP[0], tileTime);
                            }
                        }
                        else if (tileLeft > entity.pos[0]) {
                            tileNormal[0] = -1;
                            if (entity.dP[0] > 0) {
                                const distance = (x * TILE_SIZE) - (entity.pos[0] + entity.radius);
                                tileTime = Math.min(distance / entity.dP[0], tileTime);
                            }
                        }
                        // TODO: Collision system crappiness! Can bump off the top corner of
                        // a tile even though you can only access the top.
                        if (tileTime >= 0 && tileTime <= bestTime) {
                            bestTime = tileTime;
                            v2.clone(normal, tileNormal);
                        }
                    }
                }
            }
        }
        v2.normalise(normal, normal);
        return { time: bestTime, normal };
    }
    /**
     * The context should be pre-transformed to the correct viewport and orientation
     */
    draw(context) {
        for (let y = 0; y < this.tiles.length; y++) {
            const row = this.tiles[y];
            for (let x = 0; x < row.length; x++) {
                const tile = row[x];
                if (tile !== 0) {
                    context.fillStyle = tileColors[tile].light;
                    context.fillRect((x * TILE_SIZE), (y * TILE_SIZE), TILE_SIZE, TILE_SIZE);
                    context.fillStyle = tileColors[tile].dark;
                    context.beginPath();
                    context.moveTo((x * TILE_SIZE), (y * TILE_SIZE));
                    context.lineTo(((1 + x) * TILE_SIZE), (y * TILE_SIZE));
                    context.lineTo(((1 + x) * TILE_SIZE), ((1 + y) * TILE_SIZE));
                    context.closePath();
                    context.fill();
                    // context.strokeStyle = 'white';
                    // context.strokeRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                }
            }
        }
    }
}

const entities = new Set();
let player = new Entity(EntityType.Player, [20, 20]);
let worldMap;
function newLevel() {
    entities.clear();
    player = new Entity(EntityType.Player, [200, 1000]);
    worldMap = new WorldMap();
    entities.add(player);
    entities.add(new Entity(EntityType.Goblin, [150, 200]));
    entities.add(new Entity(EntityType.Heart, [450, 200]));
    entities.add(new Entity(EntityType.Heart, [550, 200]));
    entities.add(new Entity(EntityType.Heart, [650, 200]));
}
//# sourceMappingURL=gameState.js.map

let lastFrameStart = 0;
function loop() {
    if (lastFrameStart === 0) {
        lastFrameStart = performance.now();
    }
    const frameStart = performance.now();
    const dT = Math.min((frameStart - lastFrameStart) / 1000, 0.2);
    lastFrameStart = frameStart;
    for (const entity of entities) {
        entity.update(dT);
    }
    context.save();
    context.fillStyle = 'black';
    context.fillRect(0, 0, canvas.width, canvas.height);
    context.translate((canvas.width / 2), (canvas.height / 2));
    context.scale(1, -1);
    context.translate(-player.pos[0], -player.pos[1]);
    worldMap.draw(context);
    for (const entity of entities) {
        if (entity.killable /*&& entity.health < entity.maxHealth*/ && entity !== player) {
            context.save();
            context.translate(entity.pos[0], entity.pos[1]);
            context.fillStyle = 'red';
            context.fillRect(-12, entity.radius + 4, 24 * (entity.health / entity.maxHealth), 5);
            context.restore();
        }
        entity.graphic.draw(context, entity.pos, [entity.radius * 2, entity.radius * 2], entity.facing);
    }
    context.restore();
    drawGUI();
    requestAnimationFrame(loop);
}
const healthGradient = context.createLinearGradient(0, 0, 100, 20);
healthGradient.addColorStop(0, 'rgb(128, 0, 0)');
healthGradient.addColorStop(1, 'rgb(255, 55, 55)');
function drawGUI() {
    context.strokeStyle = 'white';
    context.fillStyle = healthGradient;
    context.fillRect(15, 15, 100 * player.health / player.maxHealth, 20);
    context.strokeRect(15, 15, 100, 20);
}
function init() {
    newLevel();
    requestAnimationFrame(loop);
}
init();
//# sourceMappingURL=index.js.map
//# sourceMappingURL=app.min.js.map
