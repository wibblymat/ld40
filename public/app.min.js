'use strict';

const bannerQueue = [];
const topBannerQueue = [];
function addBanner(text, size) {
    if (currentBanner === text) {
        return;
    }
    for (const banner of bannerQueue) {
        if (text === banner.text) {
            return;
        }
    }
    bannerQueue.push({ text, size });
}
function addTopBanner(text, size) {
    if (currentTopBanner === text) {
        return;
    }
    for (const banner of topBannerQueue) {
        if (text === banner.text) {
            return;
        }
    }
    topBannerQueue.push({ text, size });
}
let currentTimer = 0;
let currentBanner = '';
let currentSize = 20;
const MAX_TIME = 3;
let currentTopTimer = 0;
let currentTopBanner = '';
let currentTopSize = 80;
const MAX_TOP_TIME = 3;
function drawBanner(context, dT) {
    if (currentTimer <= 0 && bannerQueue.length > 0) {
        currentTimer = MAX_TIME;
        const details = bannerQueue.shift();
        currentBanner = details.text;
        currentSize = details.size;
    }
    if (currentTimer > 0) {
        currentTimer -= dT;
    }
    else {
        currentBanner = '';
        return;
    }
    context.save();
    if (currentTimer > 2.5) {
        context.globalAlpha = 1 - ((currentTimer - 2.5) * 2);
    }
    if (currentTimer < 0.5) {
        context.globalAlpha = Math.max(0, currentTimer * 2);
    }
    context.font = `${currentSize}px "Bungee", Arial, sans-serif`;
    context.textBaseline = 'middle';
    context.fillStyle = 'white';
    context.strokeStyle = 'black';
    context.lineWidth = Math.max(1, currentSize / 20);
    context.shadowOffsetX = Math.max(1, currentSize / 8);
    context.shadowOffsetY = Math.max(1, currentSize / 8);
    const width = context.measureText(currentBanner).width;
    context.fillText(currentBanner, context.canvas.width / 4 - width / 2, context.canvas.height / 4 + 100);
    context.strokeText(currentBanner, context.canvas.width / 4 - width / 2, context.canvas.height / 4 + 100);
    context.restore();
}
function drawTopBanner(context, dT) {
    if (currentTopTimer <= 0 && topBannerQueue.length > 0) {
        currentTopTimer = MAX_TOP_TIME;
        const details = topBannerQueue.shift();
        currentTopBanner = details.text;
        currentTopSize = details.size;
    }
    if (currentTopTimer > 0) {
        currentTopTimer -= dT;
    }
    else {
        currentTopBanner = '';
        return;
    }
    context.save();
    if (currentTopTimer > 2.5) {
        context.globalAlpha = 1 - ((currentTopTimer - 2.5) * 2);
    }
    if (currentTopTimer < 0.5) {
        context.globalAlpha = Math.max(0, currentTopTimer * 2);
    }
    context.font = `${currentTopSize}px "Bungee", Arial, sans-serif`;
    context.textBaseline = 'middle';
    context.fillStyle = 'white';
    context.strokeStyle = 'black';
    context.lineWidth = Math.max(1, currentTopSize / 20);
    context.shadowOffsetX = Math.max(1, currentTopSize / 8);
    context.shadowOffsetY = Math.max(1, currentTopSize / 8);
    const width = context.measureText(currentTopBanner).width;
    context.fillText(currentTopBanner, context.canvas.width / 4 - width / 2, context.canvas.height / 4 - 100);
    context.strokeText(currentTopBanner, context.canvas.width / 4 - width / 2, context.canvas.height / 4 - 100);
    context.restore();
}
//# sourceMappingURL=banner.js.map

function err() {
    throw new Error('Something went wrong!');
}
/**
 * inputs and outputs are [0, 1], except h.
 */
function hsvToRgb(h, s, v) {
    if (s === 0) {
        return [v, v, v];
    }
    if (h >= 360) {
        h = 0;
    }
    h /= 60;
    const i = Math.floor(h);
    const ff = h - i;
    const p = v * (1 - s);
    const q = v * (1 - (s * ff));
    const t = v * (1 - (s * (1 - ff)));
    switch (i) {
        case 0:
            return [v, t, p];
        case 1:
            return [q, v, p];
        case 2:
            return [p, v, t];
        case 3:
            return [p, q, v];
        case 4:
            return [t, p, v];
        case 5:
        default:
            return [v, p, q];
    }
}
function clamp(value, min, max) {
    return Math.max(min, Math.min(max, value));
}
//# sourceMappingURL=utils.js.map

const canvas = document.getElementById('canvas');
const context = canvas.getContext('2d') || err();
canvas.width = 1920;
canvas.height = 1080;
const targetAspect = canvas.width / canvas.height;
// context.imageSmoothingEnabled = false;
context.scale(2, 2);
function resize() {
    const aspect = window.innerWidth / window.innerHeight;
    if (aspect > targetAspect) {
        canvas.style.height = window.innerHeight + 'px';
        canvas.style.width = (window.innerWidth * targetAspect / aspect) + 'px';
    }
    else {
        canvas.style.width = window.innerWidth + 'px';
        canvas.style.height = (window.innerHeight * aspect / targetAspect) + 'px';
    }
}
resize();
window.addEventListener('resize', resize);
window.addEventListener('click', () => {
    canvas.webkitRequestFullscreen();
});
document.body.appendChild(canvas);
//# sourceMappingURL=display.js.map

var Key;
(function (Key) {
    Key[Key["Space"] = 32] = "Space";
    Key[Key["Left"] = 37] = "Left";
    Key[Key["Up"] = 38] = "Up";
    Key[Key["Right"] = 39] = "Right";
    Key[Key["Down"] = 40] = "Down";
    Key[Key["One"] = 49] = "One";
    Key[Key["Two"] = 50] = "Two";
    Key[Key["A"] = 65] = "A";
    Key[Key["D"] = 68] = "D";
    Key[Key["P"] = 80] = "P";
    Key[Key["S"] = 83] = "S";
    Key[Key["W"] = 87] = "W";
})(Key || (Key = {}));
const keystate = {};
const controls = {
    isPressed(key) {
        return keystate[key];
    },
};
function keydown(e) {
    keystate[e.keyCode] = true;
    if (!document.webkitFullscreenElement) {
        canvas.webkitRequestFullscreen();
    }
}
function keyup(e) {
    keystate[e.keyCode] = false;
}
document.addEventListener('keydown', keydown);
document.addEventListener('keyup', keyup);

const v2 = {
    create(x = 0, y = 0) {
        return [x, y];
    },
    set(result, x = 0, y = 0) {
        result[0] = x;
        result[1] = y;
    },
    clone(result, a) {
        result[0] = a[0];
        result[1] = a[1];
    },
    isZero(a) {
        return a[0] === 0 && a[1] === 0;
    },
    normalise(result, a) {
        if (!v2.isZero(a)) {
            const length = v2.length(a);
            result[0] = a[0] / length;
            result[1] = a[1] / length;
        }
    },
    lengthSquared(a) {
        return a[0] ** 2 + a[1] ** 2;
    },
    length(a) {
        return Math.sqrt(v2.lengthSquared(a));
    },
    distanceSquared(a, b) {
        return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2;
    },
    distance(a, b) {
        return Math.sqrt(this.distanceSquared(a, b));
    },
    angle(a) {
        return Math.atan2(a[1], a[0]);
    },
    add(result, a, b) {
        result[0] = a[0] + b[0];
        result[1] = a[1] + b[1];
    },
    sub(result, a, b) {
        result[0] = a[0] - b[0];
        result[1] = a[1] - b[1];
    },
    mul(result, a, scalar) {
        result[0] = a[0] * scalar;
        result[1] = a[1] * scalar;
    },
    rotate(result, a, angle) {
        const s = Math.sin(angle);
        const c = Math.cos(angle);
        const x = a[0];
        const y = a[1];
        result[0] = c * x - s * y;
        result[1] = s * x + c * y;
    },
    invert(result, a) {
        result[0] = -a[0];
        result[1] = -a[1];
    },
    dot(a, b) {
        return a[0] * b[0] + a[1] * b[1];
    },
};
//# sourceMappingURL=maths.js.map

// GJK/Mikowski collision
const ao = v2.create();
const ab = v2.create();
const ac = v2.create();
function update(simplex, direction) {
    const last = simplex[simplex.length - 1];
    const n = simplex.length;
    if (n === 1) {
        direction[0] = -last[0];
        direction[1] = -last[1];
        return false;
    }
    v2.invert(ao, last);
    v2.sub(ab, simplex[0], last);
    if (n === 2) {
        direction[0] = -ab[1];
        direction[1] = ab[0];
        if (v2.dot(direction, ao) < 0) {
            direction[0] = -direction[0];
            direction[1] = -direction[1];
        }
        return false;
    }
    if (n === 3) {
        direction[0] = -ab[1];
        direction[1] = ab[0];
        if (v2.dot(direction, simplex[1]) > 0) {
            direction[0] = -direction[0];
            direction[1] = -direction[1];
        }
        if (v2.dot(direction, ao) > 0) {
            simplex[1] = simplex[2];
            const old = simplex.pop();
            return false;
        }
        v2.sub(ac, simplex[1], last);
        direction[0] = -ac[1];
        direction[1] = ac[0];
        if (v2.dot(direction, simplex[0]) > 0) {
            direction[0] = -direction[0];
            direction[1] = -direction[1];
        }
        if (v2.dot(direction, ao) > 0) {
            simplex.shift();
            return false;
        }
        return true;
    }
    return false;
}
const inverseDirection = v2.create();
function combineSupport(support1, support2) {
    // TODO: cache these functions
    return (direction) => {
        v2.invert(inverseDirection, direction);
        const s1 = support1(direction);
        const s2 = support2(inverseDirection);
        v2.sub(s1, s1, s2);
        return s1;
    };
}
function intersect(support1, support2) {
    return intersection(combineSupport(support1, support2));
}
function intersection(support) {
    const simplex = [];
    const direction = v2.create(1, 0);
    while (true) {
        const a = support(direction);
        if (v2.dot(a, direction) < 0) {
            return false;
        }
        simplex.push(a);
        if (update(simplex, direction)) {
            return true;
        }
    }
}
//# sourceMappingURL=collision.js.map

var EntityType;
(function (EntityType) {
    EntityType[EntityType["Player"] = 0] = "Player";
    EntityType[EntityType["Heart"] = 1] = "Heart";
    EntityType[EntityType["Mcguffin"] = 2] = "Mcguffin";
    EntityType[EntityType["Goblin"] = 3] = "Goblin";
    EntityType[EntityType["GoblinArcher"] = 4] = "GoblinArcher";
    EntityType[EntityType["Projectile"] = 5] = "Projectile";
    EntityType[EntityType["Exit"] = 6] = "Exit";
    EntityType[EntityType["Spikes"] = 7] = "Spikes";
    EntityType[EntityType["Grenade"] = 8] = "Grenade";
    EntityType[EntityType["Explosion"] = 9] = "Explosion";
    EntityType[EntityType["GrenadePickup"] = 10] = "GrenadePickup";
    EntityType[EntityType["Floater"] = 11] = "Floater";
})(EntityType || (EntityType = {}));
//# sourceMappingURL=entityType.js.map

const TILE_SIZE = 32;
const tileColors = [];
const s = 1;
const highV = 0.8;
const lowV = 0.5;
for (let i = 0; i < 16; i++) {
    const h = (360 / 16) * i;
    const [r, g, b] = hsvToRgb(h, s, highV);
    const [dr, dg, db] = hsvToRgb(h, s, lowV);
    tileColors[i] = {
        dark: `rgb(${Math.floor(dr * 256)}, ${Math.floor(dg * 256)}, ${Math.floor(db * 256)}`,
        light: `rgb(${Math.floor(r * 256)}, ${Math.floor(g * 256)}, ${Math.floor(b * 256)}`,
    };
}
class WorldMap {
    constructor(data) {
        this.objectLayers = [];
        this.tileLayers = [];
        this.data = data;
        for (const layer of data.layers) {
            if (layer.type === 'tilelayer') {
                const tileLayer = layer;
                this.tileLayers.push(tileLayer);
                this.width = tileLayer.width;
                this.height = tileLayer.height;
                for (let i = 0; i < tileLayer.data.length; i++) {
                    if (tileLayer.data[i] !== 0) {
                        // tileLayer.data[i] = Math.floor(Math.random() * 15) + 1;
                        tileLayer.data[i] = (i % 15) + 1;
                    }
                }
            }
            else if (layer.type === 'objectgroup') {
                const objectLayer = layer;
                this.objectLayers.push(objectLayer);
            }
        }
    }
    getTileIndex(x, y) {
        return ((this.height - y - 1) * this.width) + x;
    }
    translateObjectPosition(x, y) {
        return [x, (this.height * TILE_SIZE) + 31 - y];
    }
    willCollide(entity, tileX, tileY) {
        const entitySupport = entity.collisionSupport.bind(entity);
        const tileSupport = (direction) => {
            const result = v2.create(tileX * TILE_SIZE, tileY * TILE_SIZE);
            if (direction[0] > 0) {
                result[0] += TILE_SIZE;
            }
            if (direction[1] > 0) {
                result[1] += TILE_SIZE;
            }
            return result;
        };
        return intersect(entitySupport, tileSupport);
    }
    findCollision(entity) {
        const minX = Math.min(entity.dP[0], 0) + entity.pos[0] - entity.radius;
        const minY = Math.min(entity.dP[1], 0) + entity.pos[1] - entity.radius;
        const maxX = Math.max(entity.dP[0], 0) + entity.pos[0] + entity.radius;
        const maxY = Math.max(entity.dP[1], 0) + entity.pos[1] + entity.radius;
        const minTileX = Math.max(0, Math.floor(minX / TILE_SIZE));
        const minTileY = Math.max(0, Math.floor(minY / TILE_SIZE));
        const maxTileX = Math.floor(maxX / TILE_SIZE);
        const maxTileY = Math.floor(maxY / TILE_SIZE);
        const currentTileX = Math.floor(entity.pos[0] / TILE_SIZE);
        const currentTileY = Math.floor(entity.pos[1] / TILE_SIZE);
        const normal = [0, 0];
        let bestTime = 1;
        for (let y = minTileY; y <= maxTileY && y < this.height; y++) {
            for (let x = minTileX; x <= maxTileX && x < this.width; x++) {
                if (this.tileLayers[0].data[this.getTileIndex(x, y)] !== 0) {
                    if (this.willCollide(entity, x, y)) {
                        const tileNormal = [0, 0];
                        let tileTime = 1;
                        const tileLeft = x * TILE_SIZE;
                        const tileRight = tileLeft + TILE_SIZE;
                        const tileBottom = y * TILE_SIZE;
                        const tileTop = tileBottom + TILE_SIZE;
                        if (tileTop < entity.pos[1]) {
                            tileNormal[1] = 1;
                            if (entity.dP[1] < 0) {
                                const distance = ((y + 1) * TILE_SIZE) - (entity.pos[1] - entity.radius);
                                tileTime = Math.min(distance / entity.dP[1], tileTime);
                            }
                        }
                        else if (tileBottom > entity.pos[1]) {
                            tileNormal[1] = -1;
                            if (entity.dP[1] > 0) {
                                const distance = (y * TILE_SIZE) - (entity.pos[1] + entity.radius);
                                tileTime = Math.min(distance / entity.dP[1], tileTime);
                            }
                        }
                        else if (tileRight < entity.pos[0]) {
                            tileNormal[0] = 1;
                            if (entity.dP[0] < 0) {
                                const distance = ((x + 1) * TILE_SIZE) - (entity.pos[0] - entity.radius);
                                tileTime = Math.min(distance / entity.dP[0], tileTime);
                            }
                        }
                        else if (tileLeft > entity.pos[0]) {
                            tileNormal[0] = -1;
                            if (entity.dP[0] > 0) {
                                const distance = (x * TILE_SIZE) - (entity.pos[0] + entity.radius);
                                tileTime = Math.min(distance / entity.dP[0], tileTime);
                            }
                        }
                        // TODO: Collision system crappiness! Can bump off the top corner of
                        // a tile even though you can only access the top.
                        if (tileTime >= 0 && tileTime <= bestTime) {
                            bestTime = tileTime;
                            v2.clone(normal, tileNormal);
                        }
                    }
                }
            }
        }
        v2.normalise(normal, normal);
        return { time: bestTime, normal };
    }
    /**
     * The context should be pre-transformed to the correct viewport and orientation
     */
    draw(context) {
        for (let y = 0; y < this.height; y++) {
            for (let x = 0; x < this.width; x++) {
                const tile = this.tileLayers[0].data[this.getTileIndex(x, y)];
                if (tile !== 0) {
                    context.fillStyle = tileColors[tile].light;
                    context.fillRect((x * TILE_SIZE), (y * TILE_SIZE), TILE_SIZE, TILE_SIZE);
                    context.fillStyle = tileColors[tile].dark;
                    context.beginPath();
                    context.moveTo((x * TILE_SIZE), (y * TILE_SIZE));
                    context.lineTo(((1 + x) * TILE_SIZE), (y * TILE_SIZE));
                    context.lineTo(((1 + x) * TILE_SIZE), ((1 + y) * TILE_SIZE));
                    context.closePath();
                    context.fill();
                    // context.strokeStyle = 'white';
                    // context.strokeRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                }
            }
        }
    }
}

const levelFiles = ['level1.json', 'level2.json', 'level3.json', 'level4.json'];
const levels = [];
const levelsLoaded = Promise.all(levelFiles.map(loadLevel));
function getLevel(id) {
    return levels[id % levels.length];
}
async function loadLevel(name, index) {
    const response = await fetch(`levels/${name}`);
    const data = await response.json();
    const map = new WorldMap(data);
    const level = new Level(map);
    levels[index] = level;
}
// Stupidness. Tiled shows the ids as one less than actually found in the file
var MapObjectType;
(function (MapObjectType) {
    MapObjectType[MapObjectType["Spawn"] = 65] = "Spawn";
    MapObjectType[MapObjectType["Exit"] = 66] = "Exit";
    MapObjectType[MapObjectType["Creature1"] = 97] = "Creature1";
    MapObjectType[MapObjectType["Creature2"] = 98] = "Creature2";
    MapObjectType[MapObjectType["Creature3"] = 99] = "Creature3";
    MapObjectType[MapObjectType["GrenadePickup"] = 100] = "GrenadePickup";
    MapObjectType[MapObjectType["Mcguffin"] = 129] = "Mcguffin";
    MapObjectType[MapObjectType["Heart"] = 130] = "Heart";
    MapObjectType[MapObjectType["Spikes"] = 131] = "Spikes";
})(MapObjectType || (MapObjectType = {}));
const ObjectToEntityMap = {
    [MapObjectType.Exit]: EntityType.Exit,
    [MapObjectType.Creature1]: EntityType.Goblin,
    [MapObjectType.Creature2]: EntityType.GoblinArcher,
    [MapObjectType.Creature3]: EntityType.Floater,
    [MapObjectType.Heart]: EntityType.Heart,
    [MapObjectType.Mcguffin]: EntityType.Mcguffin,
    [MapObjectType.Spikes]: EntityType.Spikes,
    [MapObjectType.GrenadePickup]: EntityType.GrenadePickup,
};
class Level {
    constructor(map) {
        this.map = map;
        this.spawn = v2.create();
        this.mcguffinCount = 0;
        // TODO: Set spawn from map here
        for (const layer of map.objectLayers) {
            for (const obj of layer.objects) {
                const type = obj.gid;
                if (type === MapObjectType.Spawn) {
                    v2.clone(this.spawn, map.translateObjectPosition(obj.x, obj.y));
                }
                if (type === MapObjectType.Mcguffin) {
                    this.mcguffinCount++;
                }
            }
        }
    }
    getEntities() {
        const result = [];
        for (const layer of this.map.objectLayers) {
            for (const obj of layer.objects) {
                const type = obj.gid;
                if (ObjectToEntityMap[type]) {
                    result.push(new Entity(ObjectToEntityMap[type], this.map.translateObjectPosition(obj.x, obj.y)));
                }
            }
        }
        return result;
    }
}

var WeaponType;
(function (WeaponType) {
    WeaponType[WeaponType["Gun"] = 0] = "Gun";
    WeaponType[WeaponType["Grenade"] = 1] = "Grenade";
})(WeaponType || (WeaponType = {}));
const entities = new Set();
let player;
let level;
let paused = false;
const weaponsAvailable = [WeaponType.Gun];
const debuffs = {
    doubleDamage: false,
    fastMonsters: false,
    noHeal: false,
    slowRegen: false,
    undead: false,
};
let currentLevelId = 0;
function reset() {
    player = new Entity(EntityType.Player, [20, 20]);
    changeLevel(currentLevelId);
}
function togglePause() {
    paused = !paused;
}
function nextLevel() {
    changeLevel(currentLevelId + 1);
}
function addDebuff() {
    const available = [];
    if (!debuffs.doubleDamage) {
        available.push('doubleDamage');
    }
    if (!debuffs.noHeal) {
        available.push('noHeal');
    }
    if (!debuffs.fastMonsters) {
        available.push('fastMonsters');
    }
    if (!debuffs.slowRegen) {
        available.push('slowRegen');
    }
    if (!debuffs.undead) {
        available.push('undead');
    }
    const choice = Math.floor(Math.random() * available.length);
    switch (available[choice]) {
        case 'doubleDamage': {
            debuffs.doubleDamage = true;
            addBanner('Curse: Enemy Damage X2', 50);
            break;
        }
        case 'fastMonsters': {
            debuffs.fastMonsters = true;
            addBanner('Curse: Fast enemies', 50);
            break;
        }
        case 'noHeal': {
            debuffs.noHeal = true;
            addBanner('Curse: No healing', 50);
            break;
        }
        case 'slowRegen': {
            debuffs.slowRegen = true;
            addBanner('Curse: Ammo regen 50%', 50);
            break;
        }
        case 'undead': {
            debuffs.undead = true;
            addBanner(`Curse: Enemies don't stay dead`, 45);
            break;
        }
    }
}
function changeLevel(id) {
    addTopBanner(`Level ${id + 1}`, 80);
    if (id === 0) {
        addBanner('A,  D to move', 30);
        addBanner('Space to jump', 30);
        addBanner('Arrow keys shoot', 30);
        addBanner('Collect cursed lava lamps to open the door', 30);
        addBanner('Lava lamp curses last the rest of the level', 30);
        addBanner('(or until you die!)', 30);
    }
    debuffs.doubleDamage = false;
    debuffs.fastMonsters = false;
    debuffs.noHeal = false;
    debuffs.slowRegen = false;
    debuffs.undead = false;
    currentLevelId = id;
    level = getLevel(id);
    entities.clear();
    v2.clone(player.pos, level.spawn);
    player.mcguffins = [];
    const levelEntities = level.getEntities();
    entities.add(player);
    for (const entity of levelEntities) {
        entities.add(entity);
    }
}
//# sourceMappingURL=gameState.js.map

const spritesheet = new Image();
const spritesLoaded = new Promise((resolve, reject) => {
    spritesheet.onload = resolve;
    spritesheet.onerror = reject;
});
spritesheet.src = 'assets/sprites.png';
function getCanvas(width, height) {
    const canvas = document.createElement('canvas');
    canvas.width = width;
    canvas.height = height;
    const context = canvas.getContext('2d') || err();
    return [canvas, context];
}
function makeGoblinGraphic(color) {
    const [canvas, context] = getCanvas(20, 20);
    context.translate(10, 10);
    context.fillStyle = color;
    context.strokeStyle = 'white';
    context.beginPath();
    context.arc(0, 0, 8, 0, Math.PI * 2, false);
    context.fill();
    context.stroke();
    context.fillRect(8, -4, 2, 8);
    return canvas;
}
function makePlayerGraphic() {
    const [canvas, context] = getCanvas(16, 16);
    context.fillStyle = 'purple';
    context.strokeStyle = 'white';
    context.fillRect(0, 0, 16, 16);
    context.strokeRect(0, 0, 16, 16);
    return canvas;
}
function makeFallbackGraphic() {
    const [canvas, context] = getCanvas(32, 32);
    context.fillStyle = 'blue';
    context.fillRect(0, 0, 32, 32);
    context.strokeStyle = 'white';
    context.beginPath();
    context.moveTo(0, 0);
    context.lineTo(31, 31);
    context.moveTo(0, 31);
    context.lineTo(31, 0);
    context.stroke();
    return canvas;
}
function makeProjectileGraphic() {
    const [canvas, context] = getCanvas(10, 10);
    context.fillStyle = 'yellow';
    context.strokeStyle = 'black';
    context.beginPath();
    context.arc(4, 4, 4, 0, Math.PI * 2, false);
    context.fill();
    context.stroke();
    return canvas;
}
function makeGrenadeGraphic() {
    const [canvas, context] = getCanvas(16, 16);
    context.fillStyle = 'black';
    context.strokeStyle = 'black';
    context.beginPath();
    context.arc(8, 8, 8, 0, Math.PI * 2, false);
    context.fill();
    context.beginPath();
    context.moveTo(8, 8);
    context.lineTo(16, 16);
    context.stroke();
    context.strokeStyle = 'yellow';
    context.beginPath();
    context.moveTo(15, 15);
    context.lineTo(16, 16);
    context.stroke();
    return canvas;
}
function makeHeartGraphic() {
    const [canvas, context] = getCanvas(32, 32);
    const tileX = 1;
    const tileY = 4;
    spritesLoaded.then(() => {
        context.translate(0, 32);
        context.scale(1, -1);
        context.drawImage(spritesheet, tileX * 32, tileY * 32, 32, 32, 0, 0, 32, 32);
    });
    return canvas;
}
function makeMcguffinGraphic() {
    const [canvas, context] = getCanvas(32, 32);
    const tileX = 0;
    const tileY = 4;
    spritesLoaded.then(() => {
        context.translate(0, 32);
        context.scale(1, -1);
        context.drawImage(spritesheet, tileX * 32, tileY * 32, 32, 32, 0, 0, 32, 32);
    });
    return canvas;
}
function makeExitGraphic() {
    const [canvas, context] = getCanvas(32, 32);
    const tileX = 1;
    const tileY = 2;
    spritesLoaded.then(() => {
        context.translate(0, 32);
        context.scale(1, -1);
        context.drawImage(spritesheet, tileX * 32, tileY * 32, 32, 32, 0, 0, 32, 32);
    });
    return canvas;
}
function makeSpikesGraphic() {
    const [canvas, context] = getCanvas(32, 32);
    const tileX = 2;
    const tileY = 4;
    spritesLoaded.then(() => {
        context.translate(0, 32);
        context.scale(1, -1);
        context.drawImage(spritesheet, tileX * 32, tileY * 32, 32, 32, 0, 0, 32, 32);
    });
    return canvas;
}
function makeFloaterGraphic() {
    const [canvas, context] = getCanvas(32, 32);
    const tileX = 0;
    const tileY = 3;
    spritesLoaded.then(() => {
        context.translate(0, 32);
        context.scale(1, -1);
        context.drawImage(spritesheet, tileX * 32, tileY * 32, 32, 32, 0, 0, 32, 32);
    });
    return canvas;
}
function makeGunIconGraphic() {
    const [canvas, context] = getCanvas(32, 32);
    const tileX = 3;
    const tileY = 4;
    spritesLoaded.then(() => {
        // context.translate(0, 32);
        // context.scale(1, -1);
        context.drawImage(spritesheet, tileX * 32, tileY * 32, 32, 32, 0, 0, 32, 32);
    });
    return canvas;
}
function makeBombIconGraphic() {
    const [canvas, context] = getCanvas(32, 32);
    const tileX = 3;
    const tileY = 3;
    spritesLoaded.then(() => {
        // context.translate(0, 32);
        // context.scale(1, -1);
        context.drawImage(spritesheet, tileX * 32, tileY * 32, 32, 32, 0, 0, 32, 32);
    });
    return canvas;
}
const playerGraphic = makePlayerGraphic();
const fallbackGraphic = makeFallbackGraphic();
const goblinGraphic = makeGoblinGraphic('orange');
const goblinArcherGraphic = makeGoblinGraphic('red');
const heartGraphic = makeHeartGraphic();
const mcguffinGraphic = makeMcguffinGraphic();
const projectileGraphic = makeProjectileGraphic();
const exitGraphic = makeExitGraphic();
const spikesGraphic = makeSpikesGraphic();
const grenadeGraphic = makeGrenadeGraphic();
const gunIconGraphic = makeGunIconGraphic();
const bombIconGraphic = makeBombIconGraphic();
const floaterGraphic = makeFloaterGraphic();
//# sourceMappingURL=graphic.js.map

const images = [
    'sprites.png',
];
const music = [];
const other = [
    'click.wav',
    'click2.wav',
    'explosion1.wav',
    'pop.wav',
    'squelch1.wav',
    'urgh.wav',
    'whoop.wav',
];
const loaded = new Map();
function makeURL(filename) {
    return `assets/${filename}`;
}
let pending = 0;
const assetsLoaded = new Promise((resolve, reject) => {
    const success = (url, object) => {
        pending--;
        loaded.set(url, object);
        if (pending === 0) {
            resolve();
        }
    };
    const fail = (url, err) => {
        pending--;
        console.log(`Couldn't load ${url}: ${err}`);
        if (pending === 0) {
            resolve();
        }
    };
    for (const imageURL of images) {
        pending++;
        const image = new Image();
        image.src = makeURL(imageURL);
        image.onload = () => success(imageURL, image);
        image.onerror = (e) => fail(imageURL, e.error);
    }
    for (const musicURL of music) {
        pending++;
        const audio = document.createElement('audio');
        audio.src = makeURL(musicURL);
        audio.oncanplay = () => success(musicURL, audio);
        audio.onerror = (e) => fail(musicURL, e.error);
    }
    for (const url of other) {
        pending++;
        fetch(makeURL(url)).then((response) => response.arrayBuffer())
            .then((buffer) => success(url, buffer))
            .catch((reason) => fail(url, reason));
    }
});
// TODO: Progress meter
function getAsset(name) {
    return loaded.get(name);
}
//# sourceMappingURL=assets.js.map

const soundAssets = [
    'click',
    'click2',
    'explosion1',
    'pop',
    'squelch1',
    'urgh',
    'whoop',
];
const sounds = new Map();
const context$1 = new AudioContext();
const soundGainNode = context$1.createGain();
const musicGainNode = context$1.createGain();
soundGainNode.connect(context$1.destination);
musicGainNode.connect(context$1.destination);
assetsLoaded.then(() => {
    for (const name of soundAssets) {
        const data = getAsset(`${name}.wav`);
        context$1.decodeAudioData(data, (buffer) => {
            sounds.set(name, buffer);
        });
    }
});
class SoundManager {
    get musicVolume() {
        return musicGainNode.gain.value;
    }
    set musicVolume(value) {
        value = clamp(value, 0, 1);
        musicGainNode.gain.value = value;
    }
    get soundVolume() {
        return soundGainNode.gain.value;
    }
    set soundVolume(value) {
        value = clamp(value, 0, 1);
        soundGainNode.gain.value = value;
    }
    play(name) {
        if (sounds.has(name)) {
            const source = context$1.createBufferSource();
            source.buffer = sounds.get(name);
            source.connect(soundGainNode);
            source.start();
        }
    }
    connectMusic(audio) {
        const source = context$1.createMediaElementSource(audio);
        source.connect(musicGainNode);
    }
}
var sound = new SoundManager();
//# sourceMappingURL=sound.js.map

const g = [0, -980];
var Faction;
(function (Faction) {
    Faction[Faction["Foe"] = 0] = "Foe";
    Faction[Faction["Friend"] = 1] = "Friend";
    Faction[Faction["Neither"] = 2] = "Neither";
})(Faction || (Faction = {}));
var Facing;
(function (Facing) {
    Facing[Facing["Left"] = 0] = "Left";
    Facing[Facing["Right"] = 1] = "Right";
    Facing[Facing["Up"] = 2] = "Up";
    Facing[Facing["Down"] = 3] = "Down";
})(Facing || (Facing = {}));
var CollisionResponse;
(function (CollisionResponse) {
    CollisionResponse[CollisionResponse["Bounce"] = 0] = "Bounce";
    CollisionResponse[CollisionResponse["Stop"] = 1] = "Stop";
    CollisionResponse[CollisionResponse["Deflect"] = 2] = "Deflect";
    CollisionResponse[CollisionResponse["TurnAround"] = 3] = "TurnAround";
})(CollisionResponse || (CollisionResponse = {}));
class Entity {
    constructor(type, pos, options = {}) {
        this.pos = v2.create();
        this.dP = v2.create();
        this.v = v2.create();
        this.dV = v2.create();
        this.facing = Facing.Right;
        // flags
        this.collidable = true; // Does this entity interact with things in the same space?
        this.killable = false;
        this.controlled = false;
        // solid = false; // Solid entities cannot be in the same space as each other
        this.limitedLife = false;
        this.harmful = false;
        this.flying = false;
        this.onGround = false;
        this.pacer = false;
        this.destroyOnUse = false;
        this.collectable = false;
        this.undead = false;
        this.explodes = false;
        this.isExplosion = false; // Fairly desperate stuff at this hour
        this.floater = false;
        this.collisionResponse = CollisionResponse.Deflect;
        this.health = 0;
        this.maxHealth = 100;
        this.speed = 1000;
        this.lifespan = 0;
        this.damage = 0;
        this.faction = Faction.Foe;
        // TODO: Weapons should be their own thing, not part of entity
        this.weaponTimer = 0;
        this.weaponRange = 200;
        this.radius = 8;
        this.target = null;
        this.mcguffins = []; // TODO: Make these better typed
        this.cooldown = 0; // Generic, used for lots of things
        this.ammo = 0;
        this.ammoMax = 0;
        this.ammoRegen = 1;
        this.ammoTimer = 0;
        this.weaponType = WeaponType.Gun;
        this.explosionTimer = 0;
        this.graphic = fallbackGraphic;
        v2.clone(this.pos, pos);
        switch (type) {
            case EntityType.Player: {
                this.controlled = true;
                this.killable = true;
                this.maxHealth = 100;
                this.graphic = playerGraphic;
                this.speed = 2000;
                // this.solid = true;
                this.faction = Faction.Friend;
                this.ammoMax = 50;
                this.ammo = 50;
                break;
            }
            case EntityType.Floater: {
                this.killable = true;
                this.maxHealth = 10;
                this.health = 10;
                this.graphic = floaterGraphic;
                this.speed = 500;
                this.radius = 8;
                this.harmful = true;
                this.damage = 100;
                this.flying = true;
                this.floater = true;
                this.collisionResponse = CollisionResponse.Bounce;
                this.target = player;
                break;
            }
            case EntityType.GrenadePickup: {
                this.graphic = bombIconGraphic;
                this.faction = Faction.Friend;
                this.radius = 16;
                this.onhit = (other) => {
                    weaponsAvailable.push(WeaponType.Grenade);
                    addBanner('New Weapon: Grenades', 40);
                    this.die();
                };
                break;
            }
            case EntityType.Goblin: {
                this.killable = true;
                this.maxHealth = 20;
                this.graphic = goblinGraphic;
                this.speed = 1000;
                // this.solid = true;
                this.pacer = true;
                this.harmful = true;
                this.damage = 100;
                this.collisionResponse = CollisionResponse.TurnAround;
                break;
            }
            case EntityType.GoblinArcher: {
                this.killable = true;
                this.maxHealth = 40;
                this.graphic = goblinArcherGraphic;
                this.speed = 1000;
                // this.solid = true;
                this.pacer = true;
                this.harmful = true;
                this.damage = 100;
                this.collisionResponse = CollisionResponse.TurnAround;
                this.target = player;
                this.ammo = 100;
                this.ammoMax = 100;
                this.ammoRegen = 0.1;
                break;
            }
            case EntityType.Spikes: {
                this.graphic = spikesGraphic;
                this.harmful = true;
                this.damage = 100;
                this.flying = true;
                break;
            }
            case EntityType.Projectile: {
                this.graphic = projectileGraphic;
                this.faction = options.faction || Faction.Foe;
                this.facing = options.facing || Facing.Left;
                switch (this.facing) {
                    case Facing.Left: {
                        v2.set(this.v, -1000, 0);
                        break;
                    }
                    case Facing.Right: {
                        v2.set(this.v, 1000, 0);
                        break;
                    }
                    case Facing.Up: {
                        v2.set(this.v, 0, 1000);
                        break;
                    }
                    case Facing.Down: {
                        v2.set(this.v, 0, -1000);
                        break;
                    }
                }
                this.radius = 4;
                this.limitedLife = true;
                this.lifespan = 2;
                this.harmful = true;
                this.damage = 10;
                this.flying = true;
                this.destroyOnUse = true;
                break;
            }
            case EntityType.Heart: {
                this.graphic = heartGraphic;
                this.faction = Faction.Friend;
                this.radius = 16;
                this.collectable = true;
                this.health = 30;
                break;
            }
            case EntityType.Grenade: {
                this.graphic = grenadeGraphic;
                this.radius = 8;
                this.faction = options.faction || Faction.Foe;
                this.explosionTimer = 2;
                this.explodes = true;
                this.facing = options.facing || Facing.Left;
                switch (this.facing) {
                    case Facing.Left: {
                        v2.set(this.v, -400, 300);
                        break;
                    }
                    case Facing.Right: {
                        v2.set(this.v, 400, 300);
                        break;
                    }
                    case Facing.Up: {
                        v2.set(this.v, 0, 500);
                        break;
                    }
                    case Facing.Down: {
                        v2.set(this.v, 0, -500);
                        break;
                    }
                }
                break;
            }
            case EntityType.Explosion: {
                this.radius = 0;
                this.damage = 100;
                this.faction = Faction.Neither;
                this.harmful = true;
                this.isExplosion = true;
                this.flying = true;
                this.limitedLife = true;
                this.lifespan = 1;
                break;
            }
            case EntityType.Exit: {
                this.graphic = exitGraphic;
                this.faction = Faction.Friend;
                this.radius = 16;
                this.flying = true;
                this.onhit = () => {
                    if (level.mcguffinCount === player.mcguffins.length) {
                        nextLevel();
                    }
                    else {
                        if (this.cooldown === 0) {
                            addBanner('Collect more Lava Lamps', 20);
                            sound.play('click2');
                            this.cooldown += 0.5;
                        }
                    }
                };
                break;
            }
            case EntityType.Mcguffin: {
                this.graphic = mcguffinGraphic;
                this.faction = Faction.Friend;
                this.radius = 16;
                this.onhit = (entity) => {
                    // TODO: show something to the player about the new effect
                    // TODO: Create some effects
                    entity.mcguffins.push({});
                    addDebuff();
                    sound.play('click');
                    this.die();
                };
                break;
            }
        }
        if (this.killable) {
            this.health = this.maxHealth;
        }
    }
    update(dT) {
        v2.set(this.dV, 0, 0);
        if (this.weaponTimer > 0) {
            this.weaponTimer = Math.max(0, this.weaponTimer - dT);
        }
        if (this.cooldown > 0) {
            this.cooldown = Math.max(0, this.cooldown - dT);
        }
        if (this.limitedLife) {
            this.lifespan -= dT;
        }
        if (this.lifespan < 0) {
            return this.die();
        }
        if (this.health <= 0 && this.killable) {
            if (debuffs.undead && this !== player) {
                this.undead = true;
                this.speed = 0;
                this.health = 10;
            }
            else {
                return this.die();
            }
        }
        if (this.explodes) {
            this.explosionTimer -= dT;
            if (this.explosionTimer < 0) {
                entities.add(new Entity(EntityType.Explosion, this.pos));
                this.die();
            }
        }
        if (this.isExplosion) {
            this.radius = Math.pow(1 - this.lifespan, 0.5) * 50;
        }
        if (this.undead && this.speed < 1000) {
            this.speed += 100 * dT;
        }
        if (this.ammo === this.ammoMax) {
            this.ammoTimer = Math.max(0, this.ammoTimer);
        }
        else if (this.ammoTimer > 0) {
            this.ammoTimer -= dT;
        }
        if (this.ammo < this.ammoMax && this.ammoTimer <= 0) {
            this.ammo++;
            this.ammoTimer += this.ammoRegen;
            if (debuffs.slowRegen) {
                this.ammoTimer += this.ammoRegen;
            }
        }
        if (this.controlled) {
            this.playerControl(dT);
        }
        else {
            if (this.pacer) {
                this.dV[0] = this.facing === Facing.Left ? -1 : 1;
            }
            if (this.target) {
                const tVec = v2.create();
                v2.sub(tVec, this.target.pos, this.pos);
                const direction = v2.angle(tVec);
                this.facing = this.target.pos[0] < this.pos[0] ? Facing.Left : Facing.Right;
                if (!this.floater) {
                    if (this.weaponRange >= v2.length(tVec)) {
                        this.shoot(this.facing);
                    }
                }
                v2.normalise(tVec, tVec);
                if (this.floater) {
                    v2.add(tVec, tVec, [Math.random() * 0.1, Math.random() * 0.1]);
                    v2.normalise(tVec, tVec);
                    if (v2.distance(this.pos, player.pos) > 300) {
                        v2.mul(tVec, tVec, 0.05);
                    }
                }
                v2.clone(this.dV, tVec);
            }
        }
        v2.mul(this.dV, this.dV, this.speed);
        if (debuffs.fastMonsters && this.faction === Faction.Foe) {
            v2.mul(this.dV, this.dV, 2);
        }
        if (this.undead) {
            v2.mul(this.dV, this.dV, 0.5);
        }
        if (!this.onGround && !this.flying) {
            v2.mul(this.dV, this.dV, 0.2);
        }
        // Friction
        const fricAcc = v2.create();
        v2.mul(fricAcc, this.v, this.onGround ? -8 : -1);
        v2.add(this.dV, this.dV, fricAcc);
        if (!this.flying) {
            v2.add(this.dV, this.dV, g);
        }
        v2.mul(this.dV, this.dV, dT); // a => at
        // equations of motion
        // v = at + u
        v2.add(this.v, this.dV, this.v);
        // dP = ut + (1/2)at^2
        const ut = v2.create();
        v2.mul(ut, this.v, dT);
        v2.mul(this.dP, this.dV, 0.5 * dT); // dP = (1/2)at^2
        v2.add(this.dP, ut, this.dP);
        this.onGround = false;
        if (this.collidable) {
            let attempts = 4;
            while (attempts--) {
                const collision = level.map.findCollision(this);
                if (collision.time < 1 && !v2.isZero(collision.normal)) {
                    if (collision.normal[1] > 0.5) {
                        this.onGround = true;
                    }
                    if (attempts === 0) {
                        v2.set(this.dP, 0, 0);
                    }
                    else {
                        this.updateMove(collision.normal, collision.time);
                    }
                    this.hit(null, dT);
                }
            }
        }
        for (const other of entities) {
            if (other !== this && other.collidable && this.willCollide(other)) {
                this.hit(other, dT);
                other.hit(this, dT);
                // if (this.solid && other.solid) {
                //   // TODO: bouncing/deflection here
                //   v2.set(this.dP, 0, 0);
                // }
            }
        }
        if (this.v[0] !== 0) {
            this.facing = this.v[0] < 0 ? Facing.Left : Facing.Right;
        }
        v2.add(this.pos, this.pos, this.dP);
    }
    shoot(facing) {
        if (this.weaponTimer === 0 && this.ammo > 0) {
            if (this.weaponType === WeaponType.Gun) {
                entities.add(new Entity(EntityType.Projectile, this.pos, { facing, faction: this.faction }));
                this.ammo--;
            }
            else if (this.weaponType === WeaponType.Grenade) {
                entities.add(new Entity(EntityType.Grenade, this.pos, { facing, faction: this.faction }));
                this.ammo -= 10;
            }
            sound.play('pop');
            this.weaponTimer += 0.1;
        }
    }
    playerControl(dT) {
        v2.set(this.dV, 0, 0);
        if (controls.isPressed(Key.Space) && this.onGround) {
            this.v[1] += 600;
            sound.play('whoop');
        }
        // if (controls.isPressed(Key.S)) {
        //   this.dV[1] = -1;
        // }
        if (controls.isPressed(Key.A)) {
            this.dV[0] = -1;
        }
        if (controls.isPressed(Key.D)) {
            this.dV[0] = 1;
        }
        if (controls.isPressed(Key.Up)) {
            this.shoot(Facing.Up);
        }
        if (controls.isPressed(Key.Down)) {
            this.shoot(Facing.Down);
        }
        if (controls.isPressed(Key.Left)) {
            this.shoot(Facing.Left);
        }
        if (controls.isPressed(Key.Right)) {
            this.shoot(Facing.Right);
        }
        if (weaponsAvailable.includes(WeaponType.Gun) && controls.isPressed(Key.One)) {
            this.weaponType = WeaponType.Gun;
        }
        if (weaponsAvailable.includes(WeaponType.Grenade) && controls.isPressed(Key.Two)) {
            this.weaponType = WeaponType.Grenade;
        }
        v2.normalise(this.dV, this.dV);
    }
    collisionSupport(direction) {
        const result = v2.create();
        v2.normalise(direction, direction);
        v2.mul(result, direction, this.radius);
        v2.add(result, this.pos, result);
        if (!v2.isZero(this.dP)) {
            const angle = v2.dot(this.dP, direction);
            if (angle > 0) {
                v2.add(result, result, this.dP);
            }
        }
        return result;
    }
    willCollide(other) {
        // Assume that all entities are circles for collision
        const support = this.collisionSupport;
        return intersect(support.bind(this), support.bind(other));
    }
    updateMove(normal, proportion) {
        let bounceAmount = 1 - proportion;
        if (this.collisionResponse === CollisionResponse.Bounce) {
            bounceAmount += 0.9;
        }
        switch (this.collisionResponse) {
            case CollisionResponse.TurnAround: {
                if (this.dP[0] !== 0) {
                    this.facing = this.facing === Facing.Left ? Facing.Right : Facing.Left;
                }
            }
            case CollisionResponse.Bounce:
            case CollisionResponse.Deflect: {
                const vDiff = v2.create();
                const dpDiff = v2.create();
                v2.mul(dpDiff, normal, bounceAmount * v2.dot(this.dP, normal));
                v2.sub(this.dP, this.dP, dpDiff);
                v2.mul(vDiff, normal, bounceAmount * v2.dot(this.v, normal));
                v2.sub(this.v, this.v, vDiff);
                break;
            }
            case CollisionResponse.Stop: {
                v2.set(this.dP, 0, 0);
                v2.set(this.v, 0, 0);
                break;
            }
        }
    }
    /**
     * If other is null then we collided with a wall
     */
    hit(other, dT) {
        if (!other) {
            if (this.harmful && this.destroyOnUse) {
                this.die();
            }
            return;
        }
        if (this.onhit && other === player) {
            this.onhit(other);
        }
        if (this.killable && other.harmful && this.faction !== other.faction) {
            let damage = other.damage;
            if (this === player && debuffs.doubleDamage) {
                damage *= 2;
            }
            if (other.destroyOnUse) {
                this.health -= damage;
                sound.play('urgh');
                other.die();
            }
            else {
                if (other.cooldown === 0) {
                    this.health -= damage * 0.25;
                    other.cooldown += 0.25;
                    sound.play('urgh');
                }
            }
        }
        if (this.collectable && this.faction === other.faction) {
            if (this.health > 0 && other.health < other.maxHealth) {
                if (!debuffs.noHeal) {
                    other.health = Math.min(other.maxHealth, other.health + this.health);
                }
                return this.die();
            }
        }
    }
    die() {
        entities.delete(this);
        if (this.killable) {
            sound.play('squelch1');
        }
        if (this === player) {
            reset();
        }
    }
}

let lastFrameStart = 0;
let pauseHeld = false;
function loop() {
    if (lastFrameStart === 0) {
        lastFrameStart = performance.now();
    }
    const frameStart = performance.now();
    const dT = Math.min((frameStart - lastFrameStart) / 1000, 0.2);
    lastFrameStart = frameStart;
    if (controls.isPressed(Key.P)) {
        if (!pauseHeld) {
            togglePause();
        }
        pauseHeld = true;
    }
    else {
        pauseHeld = false;
    }
    context.save();
    context.fillStyle = 'rgb(48, 48, 128)';
    context.fillRect(0, 0, canvas.width, canvas.height);
    context.translate((canvas.width / 4), (canvas.height / 4));
    context.scale(1, -1);
    context.translate(-player.pos[0], -player.pos[1]);
    level.map.draw(context);
    if (!paused) {
        for (const entity of entities) {
            entity.update(dT);
        }
        if (player.pos[1] < 0) {
            player.die();
        }
    }
    for (const entity of entities) {
        context.save();
        context.translate(entity.pos[0], entity.pos[1]);
        if (entity.killable && entity.health < entity.maxHealth && entity !== player) {
            context.fillStyle = 'red';
            context.fillRect(-12, entity.radius + 4, 24 * (entity.health / entity.maxHealth), 5);
        }
        if (entity.facing === Facing.Left) {
            context.scale(-1, 1);
        }
        if (entity.isExplosion) {
            context.fillStyle = 'yellow';
            context.beginPath();
            context.arc(0, 0, entity.radius, 0, Math.PI * 2);
            context.fill();
        }
        else {
            context.drawImage(entity.graphic, -entity.graphic.width / 2, -entity.graphic.height / 2);
        }
        context.restore();
    }
    context.restore();
    drawTopBanner(context, dT);
    drawBanner(context, dT);
    drawGUI();
    requestAnimationFrame(loop);
}
const healthGradient = context.createLinearGradient(0, 0, 100, 20);
healthGradient.addColorStop(0, 'rgb(128, 0, 0)');
healthGradient.addColorStop(1, 'rgb(255, 55, 55)');
function drawGUI() {
    context.strokeStyle = 'white';
    context.fillStyle = healthGradient;
    context.fillRect(15, 15, 100 * player.health / player.maxHealth, 20);
    context.strokeRect(15, 15, 100, 20);
    context.font = '20px "Fredoka One", Arial, sans-serif';
    context.fillStyle = 'white';
    context.strokeStyle = 'black';
    context.textBaseline = 'top';
    context.fillText(String(player.ammo), 130, 15);
    context.strokeText(String(player.ammo), 130, 15);
    let weaponCounter = 0;
    if (weaponsAvailable.includes(WeaponType.Gun)) {
        context.fillText('1', 20, 56 + (50 * weaponCounter));
        context.drawImage(gunIconGraphic, 45, 50 + (50 * weaponCounter));
        if (player.weaponType === WeaponType.Gun) {
            context.strokeStyle = 'white';
            context.strokeRect(15, 45 + (50 * weaponCounter), 67, 42);
        }
        weaponCounter++;
    }
    if (weaponsAvailable.includes(WeaponType.Grenade)) {
        context.fillText('2', 20, 56 + (50 * weaponCounter));
        context.drawImage(bombIconGraphic, 45, 50 + (50 * weaponCounter));
        if (player.weaponType === WeaponType.Grenade) {
            context.strokeStyle = 'white';
            context.strokeRect(15, 45 + (50 * weaponCounter), 67, 42);
        }
        weaponCounter++;
    }
}
function init() {
    reset();
    requestAnimationFrame(loop);
}
const loadingImage = new Image();
loadingImage.src = 'assets/loading.png';
loadingImage.onload = () => {
    context.drawImage(loadingImage, 0, 0, canvas.width / 2, canvas.height / 2);
    setTimeout(() => {
        Promise.all([levelsLoaded, spritesLoaded]).then(init);
    }, 3000);
};
//# sourceMappingURL=index.js.map
//# sourceMappingURL=app.min.js.map
